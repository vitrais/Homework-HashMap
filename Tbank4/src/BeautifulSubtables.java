import java.util.Scanner;

public class BeautifulSubtables {
    public static void main(String[] args) {
        // Создаем объект для чтения входных данных
        Scanner scanner = new Scanner(System.in);

        // Читаем количество тестовых наборов
        int t = scanner.nextInt();

        // Обрабатываем каждый тестовый набор
        while (t-- > 0) {
            // Читаем размеры таблицы
            int n = scanner.nextInt();  // количество строк
            int m = scanner.nextInt();  // количество столбцов

            // Создаем массив для хранения таблицы
            int[][] grid = new int[n][m];

            // Заполняем таблицу значениями
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    grid[i][j] = scanner.nextInt();  // 0 - белая клетка, 1 - черная
                }
            }

            // Создаем массив для хранения размеров максимальных черных прямоугольников
            int[][] dp = new int[n][m];

            // Заполняем dp массив с помощью динамического программирования
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    if (grid[i][j] == 1) {  // если текущая клетка черная
                        if (i == 0 || j == 0) {  // если первая строка или столбец
                            dp[i][j] = 1;  // максимальный прямоугольник размера 1
                        } else {
                            // находим минимальный размер из соседних клеток и увеличиваем на 1
                            dp[i][j] = Math.min(dp[i-1][j], Math.min(dp[i][j-1], dp[i-1][j-1])) + 1;
                        }
                    } else {
                        dp[i][j] = 0;  // если клетка белая, размер прямоугольника 0
                    }
                }
            }

            // Флаг для проверки пересечений
            boolean intersect = false;

            // Проверяем все клетки на наличие пересекающихся красивых подтаблиц
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    if (dp[i][j] > 1) {  // если нашли красивую подтаблицу
                        // Проверяем соседние клетки в радиусе 1
                        for (int di = -1; di <= 1; di++) {
                            for (int dj = -1; dj <= 1; dj++) {
                                int ni = i + di;  // новая строка
                                int nj = j + dj;  // новый столбец

                                // Проверяем границы массива
                                if (ni >= 0 && ni < n && nj >= 0 && nj < m) {
                                    // Если нашли другую красивую подтаблицу рядом
                                    if (dp[ni][nj] > 1) {
                                        intersect = true;  // отмечаем пересечение
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // Выводим результат для текущего тестового набора
            if (intersect) {
                System.out.println("NO");  // есть пересекающиеся красивые подтаблицы
            } else {
                System.out.println("YES");  // все красивые подтаблицы не пересекаются
            }
        }
    }
}